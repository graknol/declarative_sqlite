import 'package:meta/meta.dart';
import 'column_builder.dart';
import 'index_builder.dart';
import 'data_types.dart';

/// Builder for defining table specifications in a database schema.
/// 
/// Supports the fluent builder pattern for defining tables with columns,
/// indices, and constraints. Automatically adds system metacolumns to all tables.
@immutable
class TableBuilder {
  const TableBuilder._({
    required this.name,
    required this.columns,
    required this.indices,
    this.compositePrimaryKey,
  });

  /// Creates a new table builder with the specified name.
  /// Automatically adds system metacolumns (systemId, systemVersion).
  TableBuilder(this.name) : 
    columns = _createSystemColumns(), 
    indices = const [],
    compositePrimaryKey = null;

  /// The table name
  final String name;
  
  /// List of columns in this table (includes system columns)
  final List<ColumnBuilder> columns;
  
  /// List of indices on this table
  final List<IndexBuilder> indices;
  
  /// Optional composite primary key column names
  final List<String>? compositePrimaryKey;
  
  /// Creates the default system metacolumns that are added to all tables
  static List<ColumnBuilder> _createSystemColumns() {
    return [
      // systemId: autogenerated GUID v4, acts as secondary primary key
      ColumnBuilder(SystemColumns.systemId, SqliteDataType.text)
          .notNull()
          .unique(),
      // systemVersion: STRING column for causal ordering (HLC)
      ColumnBuilder(SystemColumns.systemVersion, SqliteDataType.text)
          .notNull(),
    ];
  }

  /// Adds a column to this table with INTEGER data type
  TableBuilder integer(String columnName, [ColumnBuilder Function(ColumnBuilder)? configure]) {
    var column = ColumnBuilder(columnName, SqliteDataType.integer);
    if (configure != null) {
      column = configure(column);
    }
    return addColumn(column);
  }

  /// Adds a column to this table with REAL data type
  TableBuilder real(String columnName, [ColumnBuilder Function(ColumnBuilder)? configure]) {
    var column = ColumnBuilder(columnName, SqliteDataType.real);
    if (configure != null) {
      column = configure(column);
    }
    return addColumn(column);
  }

  /// Adds a column to this table with TEXT data type
  TableBuilder text(String columnName, [ColumnBuilder Function(ColumnBuilder)? configure]) {
    var column = ColumnBuilder(columnName, SqliteDataType.text);
    if (configure != null) {
      column = configure(column);
    }
    return addColumn(column);
  }

  /// Adds a column to this table with BLOB data type
  TableBuilder blob(String columnName, [ColumnBuilder Function(ColumnBuilder)? configure]) {
    var column = ColumnBuilder(columnName, SqliteDataType.blob);
    if (configure != null) {
      column = configure(column);
    }
    return addColumn(column);
  }

  /// Adds a column to this table with DATE data type (stored as TEXT in ISO8601 format)
  TableBuilder date(String columnName, [ColumnBuilder Function(ColumnBuilder)? configure]) {
    var column = ColumnBuilder(columnName, SqliteDataType.date);
    if (configure != null) {
      column = configure(column);
    }
    return addColumn(column);
  }

  /// Adds a pre-built column to this table
  TableBuilder addColumn(ColumnBuilder column) {
    // Prevent manual specification of system columns
    if (SystemColumns.isSystemColumn(column.name)) {
      throw ArgumentError('Column "${column.name}" is a reserved system column and cannot be specified manually');
    }
    
    // Check for duplicate column names
    if (columns.any((c) => c.name == column.name)) {
      throw ArgumentError('Column "${column.name}" already exists in table "$name"');
    }
    
    return TableBuilder._(
      name: name,
      columns: [...columns, column],
      indices: indices,
      compositePrimaryKey: compositePrimaryKey,
    );
  }

  /// Adds an index to this table
  TableBuilder addIndex(IndexBuilder index) {
    // Validate that all indexed columns exist in the table
    for (final columnName in index.columns) {
      if (!columns.any((c) => c.name == columnName)) {
        throw ArgumentError(
          'Cannot create index "${index.name}": column "$columnName" does not exist in table "$name"'
        );
      }
    }
    
    // Check for duplicate index names
    if (indices.any((i) => i.name == index.name)) {
      throw ArgumentError('Index "${index.name}" already exists in table "$name"');
    }
    
    return TableBuilder._(
      name: name,
      columns: columns,
      indices: [...indices, index],
      compositePrimaryKey: compositePrimaryKey,
    );
  }

  /// Creates an index on this table with one or more columns
  TableBuilder index(String indexName, List<String> columnNames, {bool unique = false}) {
    var indexBuilder = IndexBuilder(indexName, name, columnNames);
    if (unique) {
      indexBuilder = indexBuilder.makeUnique();
    }
    return addIndex(indexBuilder);
  }

  /// Sets up a composite primary key for this table using multiple columns
  TableBuilder compositeKey(List<String> columnNames) {
    // Validate that all columns exist
    for (final columnName in columnNames) {
      if (!columns.any((c) => c.name == columnName)) {
        throw ArgumentError(
          'Cannot create composite primary key: column "$columnName" does not exist in table "$name"'
        );
      }
    }
    
    // Check if any column already has individual primary key constraint
    for (final columnName in columnNames) {
      final column = columns.firstWhere((c) => c.name == columnName);
      if (column.constraints.contains(ConstraintType.primaryKey)) {
        throw ArgumentError(
          'Column "$columnName" already has an individual primary key constraint. '
          'Remove individual primary key constraints before setting up composite key.'
        );
      }
    }
    
    return TableBuilder._(
      name: name,
      columns: columns,
      indices: indices,
      compositePrimaryKey: columnNames,
    );
  }

  /// Convenience method to add a primary key column
  TableBuilder primaryKey(String columnName, SqliteDataType dataType) {
    return addColumn(ColumnBuilder(columnName, dataType).primaryKey());
  }

  /// Convenience method to add an auto-incrementing integer primary key
  TableBuilder autoIncrementPrimaryKey(String columnName) {
    return addColumn(ColumnBuilder(columnName, SqliteDataType.integer).primaryKey());
  }

  /// Gets the primary key column names for this table
  /// Returns composite primary key columns if defined, otherwise single primary key column
  List<String> getPrimaryKeyColumns() {
    if (compositePrimaryKey != null && compositePrimaryKey!.isNotEmpty) {
      return compositePrimaryKey!;
    }
    
    // Look for individual primary key column
    final primaryKeyColumn = columns
        .where((col) => col.constraints.contains(ConstraintType.primaryKey))
        .firstOrNull;
    
    if (primaryKeyColumn != null) {
      return [primaryKeyColumn.name];
    }
    
    return [];
  }
  
  /// Checks if this table has a primary key (single or composite)
  bool get hasPrimaryKey {
    return getPrimaryKeyColumns().isNotEmpty;
  }

  /// Generates the SQL CREATE TABLE statement
  String toSql() {
    if (columns.isEmpty) {
      throw StateError('Table "$name" must have at least one column');
    }
    
    final buffer = StringBuffer();
    buffer.write('CREATE TABLE $name (\n');
    
    // Add column definitions
    for (int i = 0; i < columns.length; i++) {
      buffer.write('  ${columns[i].toSql()}');
      if (i < columns.length - 1 || compositePrimaryKey != null) {
        buffer.write(',');
      }
      buffer.write('\n');
    }
    
    // Add composite primary key constraint if specified
    if (compositePrimaryKey != null && compositePrimaryKey!.isNotEmpty) {
      buffer.write('  PRIMARY KEY (${compositePrimaryKey!.join(', ')})\n');
    }
    
    buffer.write(')');
    return buffer.toString();
  }

  /// Generates SQL statements for all indices on this table
  List<String> indexSqlStatements() {
    return indices.map((index) => index.toSql()).toList();
  }

  /// Generates all SQL statements needed to create this table and its indices
  List<String> allSqlStatements() {
    return [toSql(), ...indexSqlStatements()];
  }

  @override
  String toString() => toSql();

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TableBuilder &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          _listEquals(columns, other.columns) &&
          _listEquals(indices, other.indices) &&
          _listEquals(compositePrimaryKey ?? [], other.compositePrimaryKey ?? []);

  @override
  int get hashCode =>
      name.hashCode ^
      columns.hashCode ^
      indices.hashCode ^
      (compositePrimaryKey?.hashCode ?? 0);

  /// Helper method to compare lists for equality
  bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}

/// Extension to add firstOrNull helper method
extension FirstOrNullTableBuilder<T> on Iterable<T> {
  T? get firstOrNull => isEmpty ? null : first;
}
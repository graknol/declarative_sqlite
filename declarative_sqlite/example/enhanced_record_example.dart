import 'package:declarative_sqlite/declarative_sqlite.dart';

/// Example showing the enhanced DbRecord functionality with:
/// 1. Generated typed record classes
/// 2. Singleton HLC clock for causal ordering
/// 3. RecordMapFactoryRegistry for eliminating mapper parameters

// This would typically be generated by the build system
// but shown here for demonstration purposes
class User extends DbRecord {
  User(Map<String, Object?> data, DeclarativeDatabase database)
      : super(data, 'users', database);

  // Typed getters using the helper methods
  int get id => getIntegerNotNull('id');
  String get name => getTextNotNull('name');
  String get email => getTextNotNull('email');
  int get age => getIntegerNotNull('age');
  DateTime? get birthDate => getDateTime('birth_date');
  String? get bio => getText('bio');

  // Typed setters using the helper methods
  set id(int value) => setInteger('id', value);
  set name(String value) => setText('name', value);
  set email(String value) => setText('email', value);
  set age(int value) => setInteger('age', value);
  set birthDate(DateTime? value) => setDateTime('birth_date', value);
  set bio(String? value) => setText('bio', value);

  // Factory method for the registry
  static User fromMap(Map<String, Object?> data) {
    // This would need access to the database instance
    // In practice, the generator would handle this properly
    throw UnimplementedError('Factory needs database instance');
  }
  
  // Alternative factory that takes the database
  static User fromMapWithDatabase(Map<String, Object?> data, DeclarativeDatabase database) {
    return User(data, database);
  }
}

void main() async {
  // Define schema
  final schema = SchemaBuilder()
    ..table('users', (table) {
      table.integer('id').notNull(0);
      table.text('name').notNull('');
      table.text('email').notNull('');
      table.integer('age').notNull(0);
      table.date('birth_date');
      table.text('bio').lww(); // LWW column
      table.key(['id']).primary();
    })
    ..build();

  final db = await DeclarativeDatabase.open(':memory:', schema: schema);

  try {
    print('=== Enhanced DbRecord Demo ===\n');

    // 1. Singleton HLC Clock Demo
    print('1. HLC Clock Singleton:');
    final clock1 = HlcClock();
    final clock2 = HlcClock(); 
    print('Same instance: ${identical(clock1, clock2)}'); // Should be true
    print('Clock node ID: ${clock1.nodeId}\n');

    // 2. Register factory (this would typically be done at app startup)
    print('2. Registering User factory...');
    // Note: We can't use the static fromMap because it needs database access
    // In the real generator, this would be handled properly
    RecordMapFactoryRegistry.register<User>((data) => 
        User.fromMapWithDatabase(data, db));
    print('Factory registered for User type\n');

    // 3. Insert test data
    await db.insert('users', {
      'id': 1,
      'name': 'Alice Smith',
      'email': 'alice@example.com',
      'age': 30,
      'birth_date': DateTime(1993, 5, 15).toIso8601String(),
      'bio': 'Software engineer',
    });

    // 4. Query using the old DbRecord API (still works)
    print('3. Old DbRecord API:');
    final oldRecords = await db.queryRecords(
      (q) => q.from('users').where(col('id').eq(1)),
    );
    final oldUser = oldRecords.first;
    print('Name (old way): ${oldUser.getValue<String>('name')}');
    print('Age (old way): ${oldUser.getValue<int>('age')}\n');

    // 5. Query using the new typed API with registry
    print('4. New Typed API with Registry:');
    final typedUsers = await db.queryTyped<User>(
      (q) => q.from('users').where(col('id').eq(1)),
    );
    final typedUser = typedUsers.first;
    
    // Now we have truly typed access!
    print('Name (typed): ${typedUser.name}');          // No getValue needed!
    print('Age (typed): ${typedUser.age}');            // Automatic casting!
    print('Birth Date (typed): ${typedUser.birthDate}'); // DateTime parsing!
    print('Bio (typed): ${typedUser.bio}\n');

    // 6. Demonstrate typed setters
    print('5. Typed Setters Demo:');
    typedUser.age = 31;                                  // Direct property assignment!
    typedUser.bio = 'Senior Software Engineer';         // LWW column auto-updated
    typedUser.birthDate = DateTime(1993, 5, 16);        // DateTime auto-serialized
    
    print('Modified fields: ${typedUser.modifiedFields}');
    await typedUser.save();
    print('Changes saved!\n');

    // 7. Verify the updates worked
    print('6. Verification:');
    final updatedUsers = await db.queryTyped<User>(
      (q) => q.from('users').where(col('id').eq(1)),
    );
    final updatedUser = updatedUsers.first;
    
    print('Updated age: ${updatedUser.age}');
    print('Updated bio: ${updatedUser.bio}');
    print('Updated birth date: ${updatedUser.birthDate}');

    // 8. Show the HLC was updated for LWW column
    final bioHlc = updatedUser.getRawValue('bio__hlc');
    print('Bio HLC timestamp: $bioHlc\n');

    // 9. Streaming with typed records
    print('7. Streaming with Typed Records:');
    final userStream = db.streamTyped<User>(
      (q) => q.from('users'),
    );

    final subscription = userStream.take(1).listen((users) {
      print('Stream received ${users.length} users:');
      for (final user in users) {
        print('  - ${user.name} (${user.age} years old)');
      }
    });

    await subscription.asFuture();

    print('\n=== All demos completed successfully! ===');

  } finally {
    await db.close();
  }
}

// Helper function (exported from library)
Condition col(String column) => Condition(column);
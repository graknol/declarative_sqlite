# The dream

This document demonstrates the dream API. This is the end result
that I should build towards:

```dart

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: IfsCloudAuthProvider(
        config: IfsCloudAuthConfig(
          clientId: 'work_app',
          domain: 'myinstance.ifs.cloud',
          realm: 'ifs',
        ),
        child: DatabaseProvider(
          schema: (builder) {
            builder.table('work_order', (table) {
              // Each work order has a GUID v4 as its ID
              table.guid('id').notNull();
              // Each work order must have a customer ID
              table.text('customer_id').notNull();
              table.real('total').notNull().min(0);
              table.date('start_date').notNull();
              // Each work order can have up to 16 attachments, of 8 MiB each (8*1024*1024 bytes)
              table.fileset('attachments').maxFileSize.mb(8).max(16);
              // Each work order can have up to 64 pictures, of 30 MiB each
              table.fileset('pictures').max(64).maxFileSize.mb(30);
              // The primary key of the work order table is "id"
              table.key(['id']).primary();
              // We're going to sort the work orders by start date, so we'll create an index for this to speed up the query
              table.key(['start_date']).index();
              // A single work order has a single customer
              table.reference(['customer_id']).to('customer', ['id']);
              // A single work order has many work order lines
              table.reference(['id']).toMany('work_order_line', ['id']);
              // A single work order has many work order line notes
              table.reference(['id']).toMany('work_order_line_note', ['id']);
            });
            builder.table('work_order_line', (table) {
              // Each work order line must have its work order's ID as one of its columns to be able to link them together
              table.guid('work_order_id').notNull().parent();
              // Each work order has multiple lines
              table.integer('line_no').notNull();
              // Each line has a description of up to 500 characters
              table.text('description').maxLength(500);
              // Each line must have a start date
              table.date('start_date').notNull();
              // The following 2 columns should be modifiable
              // with the Last-Write-Wins strategy
              table.real('quantity').notNull().min(0).lww();
              table.key(['work_order_id', 'line_no']).primary();
              // The index names will be generated by the following pattern: work_order_line_ix1, work_order_line_ix2. If indexes do not match, we can just recreate them.
              // All indexes automatically append all primary key columns, thus this index will actually be: [start_date, quantity, work_order_id, line_no]
              table.key(['start_date', 'quantity']).index();
              // A single work order line has a single work order
              // Since work_order_id is defined as the parent, that means the work_order is the parent of work_order_line
              table.reference(['work_order_id']).to('work_order', ['id']);
            });
            builder.table('work_order_line_note', (table) {
              table.guid('work_order_id').notNull().parent();
              table.integer('work_order_line_no').notNull().parent();
              table.guid('note_id').notNull();
              // Each note can be up to 2000 characters and multiple users can edit the same note, but the last write wins.
              table.text('note').maxLength(2000).lww();
              table.key(['work_order_id', 'work_order_line_no', 'note_id']).primary();
              // All indexes automatically append all primary key columns, thus this index will actually be: [note, work_order_id, work_order_line_no, note_no]
              table.key(['note']).index();
              // Each note has one work order line
              table.reference(['work_order_id', 'work_order_line_no']).to('work_order_line', ['work_order_id', 'line_no']);
              // Each note has one work order
              table.reference(['work_order_id']).to('work_order', ['id']);
            });
            builder.view('work_order_detail', (view) {
              view
                .select('t.id', 'work_order_id') // aliased
                .select('t.customer_id')
                .select('t.total')
                .selectSubQuery((sub) {
                  sub
                    .count()
                    .from('work_order_line', 'l')
                    .where(or([
                        and([
                          is('l.work_order_id').eq('t.id'),
                          is('l.quantity').gt(0),
                        ]),
                        is('l.description').like('IMPORTANT: %'),
                      ])
                    );
                }, 'line_count') // aliased
                .selectSubQuery((sub) {
                  sub
                    .count()
                    .from('work_order_line_note', 'n')
                    .where(and([
                        is('n.work_order_id').eq('t.id'),
                        is('n.note').not.nil(),
                      ]),
                    );
                }, 'note_count') // aliased
                .from('work_order', 't')
                .where(is('t.total').gt(5000));
            });
          },
          databaseName: 'app.db',
          child: ServerSyncManager(
            retryStrategy: RetryStrategies.exponentialBackoff(maxDelay: Duration(minutes: 3)),
            fetchInterval: Duration(seconds: 10),
            // This callback is called for all the tables in the same order they are defined in the schema. This means that you should define parents before children. This is also the reason why we're not using foreign keys, as we are syncing in an eventual consistent manner.
            onFetch: (dataAccess, tableName, clock) async {
              // We're given the name of the table to fetch and its latest hybrid logical clock that we've gotten from the server so we can ask the server for incremental updates.
              final httpClient = Dio();
              final res = await httpClient.get('https://my.api.com/fetch?table=${tableName}&after=${latestClock}');
              // Throw an exception if not successful. ServerSyncManager will retry periodically.
              res.ensureSuccessStatusCode();

              final raw = await res.content.readAsStringAsync();
              final json = jsonDecode(raw);
              // The JSON contains multiple rows, with all the necessary columns as properties (lww columns are objects with a value, a hybrid logical clock marking its causal timestamp and the ID of the user who made the change).
              // The full JSON schema for fetch/send are documented in a separate markdown file. The important thing is that everything needed to process the data is included in the schema.
              await dataAccess.bulkLoad(json);
            },
            onSend: (operations) async {
              final httpClient = Dio();
              final res = await httpClient.post('https://my.api.com/sync', operations.toJson());
              if (res.statusCode == 400) {
                // This is an unrecoverable error, so we should discard it
                return false;
              }
              if (!res.isSuccess) {
                // The upload failed, so we throw an exception so that it can be retried later
                throw ServerSyncException(res.content);
              }
              // Everything was OK, mark it as uploaded!
              return true;
            }
            child: Scaffold(
              body: QueryListView<IWorkOrder>(
                query: (query) {
                  query.selectAll().from('work_order').orderBy(['created_date']);
                },
                loadingBuilder: (context) {
                    return CircularLoadingIndicator();
                },
                errorBuilder: (context, err) {
                    return ErrorView(err);
                }
                // This itemBuilder will be re-called when the query result changes. Either because the query itself got changed, or because a dependency of the query was modified; invalidating the query.
                itemBuilder: (context, record) {
                  return ListTile(
                    title: Text(record.id),
                    subtitle: Text(record.customerId),
                    onTap: () async {
                      final sm = ScaffoldMessenger.of(context);
                      await record.setTotal(r => r.total + 500);
                      if (sm.mounted) {
                        sm.showSnackBar(SnackBar(content: Text('Incremented work order total by 500')));
                      }
                    },
                  ),
                },
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

This example is not exhaustive, but it highlights the general design choices and developer UX needs.

## Folder Structure

Each library resides in its own root folder:

- declarative_sqlite/ (this is the folder we're currently in)
- declarative_sqlite_flutter/
- ifs_cloud_auth/

## Refactoring Tasks

Refactor the three libraries, starting with the core library first, then the IFS Cloud Auth library, then lastly the flutter library.

The flutter library should use the building blocks from the other two core libraries, rather than inventing its own structures, except for widget/UI specific areas.

- All data flow and synchronization should be handled by the core library.
- All authentication flow should be handled by the core auth library.
- All visual widgets should be handled by the flutter library.

## Coding Style

- ALWAYS prefer smaller, composable widgets over big, complex widgets
- AVOID creating stateful widgets unless absolutely necessary. PREFER stateless widgets.
- PREFER composition over inheritance
- AVOID bi-directional prop passing. PREFER uni-directional passing of properties down the widget tree.
- AVOID creating proxy and helper classes to implement features. ALWAYS implement features directly in the target classes.
- AVOID creating backwards compatible alternatives for legacy code. We are still building the library, so there's no one using it yet.
- ALWAYS follow well-defined Flutter best-practices and coding patterns.
- ALWAYS immitate the API style of the core widgets in the Flutter SDK. When wrapping core widgets (i.e. ListView), expose the same props and pass them on where appropriate (i.e. `QueryListView` should accept `scrollDirection` and forward it to `ListView`'s `scrollDirection`, etc...).
- NEVER be afraid to iterate, modify and simplify the same class/method multiple times. We want to converge to a generic and clean implementation.
- ALWAYS break down long and deeply nested functions/classes into smaller functions/classes.

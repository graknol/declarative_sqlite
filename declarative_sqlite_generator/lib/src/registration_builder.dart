import 'dart:async';
import 'dart:convert';

import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:source_gen/source_gen.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/constant/value.dart';

/// Builder that collects all @RegisterFactory classes and generates a single registration file
class RegistrationCollectBuilder implements Builder {
  @override
  final buildExtensions = const {
    '.dart': ['.registration.json']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final registeredClasses = <RegistrationInfo>[];
    final library = await buildStep.inputLibrary;
    
    // Look for classes with @RegisterFactory annotation
    for (final element in library.allElements) {
      if (element is ClassElement && _extendsDbRecord(element)) {
        final dbRecordAnnotation = _getDbRecordAnnotation(element);
        final registerFactoryAnnotation = _getRegisterFactoryAnnotation(element);
        
        if (dbRecordAnnotation != null && registerFactoryAnnotation != null) {
          final tableName = _getTableNameFromAnnotation(dbRecordAnnotation);
          if (tableName != null) {
            registeredClasses.add(RegistrationInfo(
              className: element.name,
              tableName: tableName,
              libraryUri: library.identifier,
            ));
          }
        }
      }
    }
    
    // Only create output if we found registered classes
    if (registeredClasses.isNotEmpty) {
      final output = registeredClasses.map((info) => info.toJson()).toList();
      final outputId = buildStep.inputId.changeExtension('.registration.json');
      await buildStep.writeAsString(outputId, jsonEncode(output));
    }
  }

  /// Checks if the class extends DbRecord
  bool _extendsDbRecord(ClassElement element) {
    ClassElement? current = element;
    while (current != null) {
      if (current.supertype?.element?.name == 'DbRecord') {
        return true;
      }
      current = current.supertype?.element;
    }
    return false;
  }

  /// Gets the @GenerateDbRecord annotation
  DartObject? _getDbRecordAnnotation(ClassElement element) {
    for (final metadata in element.metadata) {
      final annotation = metadata.computeConstantValue();
      if (annotation?.type?.element?.name == 'GenerateDbRecord') {
        return annotation;
      }
    }
    return null;
  }

  /// Gets the @RegisterFactory annotation
  DartObject? _getRegisterFactoryAnnotation(ClassElement element) {
    for (final metadata in element.metadata) {
      final annotation = metadata.computeConstantValue();
      if (annotation?.type?.element?.name == 'RegisterFactory') {
        return annotation;
      }
    }
    return null;
  }

  /// Extracts the table name from @GenerateDbRecord annotation
  String? _getTableNameFromAnnotation(DartObject annotation) {
    return annotation.getField('tableName')?.toStringValue();
  }
}

/// Builder that aggregates all registration info and generates a single registration file
class RegistrationAggregateBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'$lib$': ['lib/generated_registrations.dart']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final allRegistrations = <RegistrationInfo>[];
    
    // Find all registration JSON files
    await for (final input in buildStep.findAssets(Glob('lib/**.registration.json'))) {
      final content = await buildStep.readAsString(input);
      final List<dynamic> registrations = jsonDecode(content);
      
      for (final reg in registrations) {
        allRegistrations.add(RegistrationInfo.fromJson(reg));
      }
    }
    
    if (allRegistrations.isNotEmpty) {
      final generatedContent = generateRegistrationFile(allRegistrations);
      final outputId = AssetId(buildStep.inputId.package, 'lib/generated_registrations.dart');
      await buildStep.writeAsString(outputId, generatedContent);
    }
  }

  String generateRegistrationFile(List<RegistrationInfo> registrations) {
    final buffer = StringBuffer();
    
    // Add imports
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by declarative_sqlite_generator');
    buffer.writeln();
    buffer.writeln("import 'package:declarative_sqlite/declarative_sqlite.dart';");
    
    // Add imports for each registered class
    final importedLibraries = <String>{};
    for (final reg in registrations) {
      // Convert library identifier to relative import
      String importPath = reg.libraryUri;
      if (importPath.startsWith('package:') && importPath.contains('/lib/')) {
        // Convert to relative path from lib directory
        importPath = importPath.split('/lib/')[1];
      }
      
      if (importedLibraries.add(importPath)) {
        buffer.writeln("import '$importPath';");
      }
    }
    buffer.writeln();
    
    // Generate the registration function
    buffer.writeln('/// Auto-generated factory registration function');
    buffer.writeln('/// Call this function to register all annotated record factories');
    buffer.writeln('void registerAllFactories(DeclarativeDatabase database) {');
    
    for (final reg in registrations) {
      buffer.writeln('  RecordMapFactoryRegistry.register<${reg.className}>((data) => ${reg.className}Generated.fromMap(data, database));');
    }
    
    buffer.writeln('}');
    
    return buffer.toString();
  }
}

/// Information about a class that should be registered
class RegistrationInfo {
  final String className;
  final String tableName;
  final String libraryUri;

  RegistrationInfo({
    required this.className,
    required this.tableName,
    required this.libraryUri,
  });

  Map<String, dynamic> toJson() => {
    'className': className,
    'tableName': tableName,
    'libraryUri': libraryUri,
  };

  factory RegistrationInfo.fromJson(Map<String, dynamic> json) => RegistrationInfo(
    className: json['className'],
    tableName: json['tableName'],
    libraryUri: json['libraryUri'],
  );
}
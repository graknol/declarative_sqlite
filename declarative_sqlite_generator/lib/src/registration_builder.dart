import 'dart:async';

import 'package:analyzer/dart/constant/value.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:glob/glob.dart';

/// Builder that collects all DbRecord classes with @GenerateDbRecord annotation and generates a registration file
class RegistrationBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'$lib$': ['generated_registrations.dart']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final registeredClasses = <RegistrationInfo>{};

    // Find all Dart files and scan for eligible classes
    await for (final input in buildStep.findAssets(Glob('lib/**/*.dart'))) {
      try {
        final library = await buildStep.resolver.libraryFor(input);

        // Look for classes that extend DbRecord and have @GenerateDbRecord annotation
        for (final element in library.definingCompilationUnit.children.whereType<ClassElement>()) {
          if (_extendsDbRecord(element)) {
            final dbRecordAnnotation = _getDbRecordAnnotation(element);
            
            if (dbRecordAnnotation != null) {
              final tableName = _getTableNameFromAnnotation(dbRecordAnnotation);
              if (tableName != null) {
                registeredClasses.add(RegistrationInfo(
                  className: element.name,
                  tableName: tableName,
                  libraryUri: library.identifier,
                ));
              }
            }
          }
        }
      } catch (e) {
        // Skip files that can't be analyzed (e.g., generated files, part files)
        continue;
      }
    }
    
    // Generate the registration file if we found any classes
    if (registeredClasses.isNotEmpty) {
      final generatedContent = _generateRegistrationFile(registeredClasses);
      final outputId = AssetId(buildStep.inputId.package, 'lib/generated_registrations.dart');
      await buildStep.writeAsString(outputId, generatedContent);
    }
  }

  /// Checks if the class extends DbRecord
  bool _extendsDbRecord(ClassElement element) {
    ClassElement? current = element;
    while (current != null) {
      if (current.supertype?.element.name == 'DbRecord') {
        return true;
      }
      final supertypeElement = current.supertype?.element;
      if (supertypeElement is ClassElement) {
        current = supertypeElement;
      } else {
        current = null;
      }
    }
    return false;
  }

  /// Gets the @GenerateDbRecord annotation
  DartObject? _getDbRecordAnnotation(ClassElement element) {
    for (final metadata in element.metadata) {
      final annotation = metadata.computeConstantValue();
      if (annotation?.type?.element?.name == 'GenerateDbRecord') {
        return annotation;
      }
    }
    return null;
  }

  /// Extracts the table name from @GenerateDbRecord annotation
  String? _getTableNameFromAnnotation(DartObject annotation) {
    return annotation.getField('tableName')?.toStringValue();
  }

  /// Generates the registration file content
  String _generateRegistrationFile(Set<RegistrationInfo> registrations) {
    final buffer = StringBuffer();
    
    // Add imports
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by declarative_sqlite_generator');
    buffer.writeln();
    buffer.writeln("import 'package:declarative_sqlite/declarative_sqlite.dart';");
    
    // Add imports for each registered class
    final importedLibraries = <String>{};
    for (final reg in registrations) {
      // Convert library identifier to a package import if possible
      String importPath = reg.libraryUri;
      if (importPath.startsWith('asset:')) {
        // Example: asset:my_package/lib/src/models.dart -> package:my_package/src/models.dart
        final parts = importPath.split('/');
        if (parts.length > 2 && parts[1] == 'lib') {
          importPath = 'package:${parts[0].substring('asset:'.length)}/${parts.sublist(2).join('/')}';
        }
      }
      
      if (importedLibraries.add(importPath)) {
        buffer.writeln("import '$importPath';");
      }
    }
    buffer.writeln();
    
    // Generate the registration function
    buffer.writeln('/// Auto-generated factory registration function');
    buffer.writeln('/// Call this function to register all annotated record factories');
    buffer.writeln('void registerAllGeneratedFactories(DeclarativeDatabase database) {');
    
    for (final reg in registrations) {
      buffer.writeln('  RecordMapFactoryRegistry.register<${reg.className}>((data, db) => ${reg.className}(data, db));');
    }
    
    buffer.writeln('}');
    
    return buffer.toString();
  }
}

/// Information about a class that should be registered
class RegistrationInfo {
  final String className;
  final String tableName;
  final String libraryUri;

  RegistrationInfo({
    required this.className,
    required this.tableName,
    required this.libraryUri,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RegistrationInfo &&
          runtimeType == other.runtimeType &&
          className == other.className &&
          tableName == other.tableName &&
          libraryUri == other.libraryUri;

  @override
  int get hashCode => className.hashCode ^ tableName.hashCode ^ libraryUri.hashCode;
}
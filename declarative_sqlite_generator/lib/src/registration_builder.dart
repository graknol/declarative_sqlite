import 'dart:async';
import 'dart:convert';

import 'package:analyzer/dart/constant/value.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:glob/glob.dart';

/// Builder that collects all @RegisterFactory classes and generates a single registration file
class RegistrationCollectBuilder implements Builder {
  @override
  final buildExtensions = const {
    '.dart': ['.registration.json']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final registeredClasses = <RegistrationInfo>[];
    final library = await buildStep.inputLibrary;

    // Look for classes with @RegisterFactory annotation
    for (final element in library.topLevelElements.whereType<ClassElement>()) {
      if (_extendsDbRecord(element)) {
        final dbRecordAnnotation = _getDbRecordAnnotation(element);
        final registerFactoryAnnotation = _getRegisterFactoryAnnotation(element);
        
        if (dbRecordAnnotation != null && registerFactoryAnnotation != null) {
          final tableName = _getTableNameFromAnnotation(dbRecordAnnotation);
          if (tableName != null) {
            registeredClasses.add(RegistrationInfo(
              className: element.name,
              tableName: tableName,
              libraryUri: library.identifier,
            ));
          }
        }
      }
    }
    
    // Only create output if we found registered classes
    if (registeredClasses.isNotEmpty) {
      final output = registeredClasses.map((info) => info.toJson()).toList();
      final outputId = buildStep.inputId.changeExtension('.registration.json');
      await buildStep.writeAsString(outputId, jsonEncode(output));
    }
  }

  /// Checks if the class extends DbRecord
  bool _extendsDbRecord(ClassElement element) {
    ClassElement? current = element;
    while (current != null) {
      if (current.supertype?.element.name == 'DbRecord') {
        return true;
      }
      final supertypeElement = current.supertype?.element;
      if (supertypeElement is ClassElement) {
        current = supertypeElement;
      } else {
        current = null;
      }
    }
    return false;
  }

  /// Gets the @GenerateDbRecord annotation
  DartObject? _getDbRecordAnnotation(ClassElement element) {
    for (final metadata in element.metadata) {
      final annotation = metadata.computeConstantValue();
      if (annotation?.type?.element?.name == 'GenerateDbRecord') {
        return annotation;
      }
    }
    return null;
  }

  /// Gets the @RegisterFactory annotation
  DartObject? _getRegisterFactoryAnnotation(ClassElement element) {
    for (final metadata in element.metadata) {
      final annotation = metadata.computeConstantValue();
      if (annotation?.type?.element?.name == 'RegisterFactory') {
        return annotation;
      }
    }
    return null;
  }

  /// Extracts the table name from @GenerateDbRecord annotation
  String? _getTableNameFromAnnotation(DartObject annotation) {
    return annotation.getField('tableName')?.toStringValue();
  }
}

/// Builder that aggregates all registration info and generates a single registration file
class RegistrationAggregateBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'$lib$': ['generated_registrations.dart']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final allRegistrations = <RegistrationInfo>{};
    
    // Find all registration JSON files across the entire project
    await for (final input in buildStep.findAssets(Glob('**/*.registration.json'))) {
      final content = await buildStep.readAsString(input);
      final List<dynamic> registrations = jsonDecode(content);
      
      for (final reg in registrations) {
        allRegistrations.add(RegistrationInfo.fromJson(reg));
      }
    }
    
    if (allRegistrations.isNotEmpty) {
      final generatedContent = generateRegistrationFile(allRegistrations);
      final outputId = AssetId(buildStep.inputId.package, 'lib/generated_registrations.dart');
      await buildStep.writeAsString(outputId, generatedContent);
    }
  }

  String generateRegistrationFile(Set<RegistrationInfo> registrations) {
    final buffer = StringBuffer();
    
    // Add imports
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by declarative_sqlite_generator');
    buffer.writeln();
    buffer.writeln("import 'package:declarative_sqlite/declarative_sqlite.dart';");
    
    // Add imports for each registered class
    final importedLibraries = <String>{};
    for (final reg in registrations) {
      // Convert library identifier to a package import if possible
      String importPath = reg.libraryUri;
      if (importPath.startsWith('asset:')) {
        // Example: asset:my_package/lib/src/models.dart -> package:my_package/src/models.dart
        final parts = importPath.split('/');
        if (parts.length > 2 && parts[1] == 'lib') {
          importPath = 'package:${parts[0].substring('asset:'.length)}/${parts.sublist(2).join('/')}';
        }
      }
      
      if (importedLibraries.add(importPath)) {
        buffer.writeln("import '$importPath';");
      }
    }
    buffer.writeln();
    
    // Generate the registration function
    buffer.writeln('/// Auto-generated factory registration function');
    buffer.writeln('/// Call this function to register all annotated record factories');
    buffer.writeln('void registerAllGeneratedFactories(DeclarativeDatabase database) {');
    
    for (final reg in registrations) {
      buffer.writeln('  RecordMapFactoryRegistry.register<${reg.className}>((data, db) => ${reg.className}(data, db));');
    }
    
    buffer.writeln('}');
    
    return buffer.toString();
  }
}

/// Information about a class that should be registered
class RegistrationInfo {
  final String className;
  final String tableName;
  final String libraryUri;

  RegistrationInfo({
    required this.className,
    required this.tableName,
    required this.libraryUri,
  });

  Map<String, dynamic> toJson() => {
    'className': className,
    'tableName': tableName,
    'libraryUri': libraryUri,
  };

  factory RegistrationInfo.fromJson(Map<String, dynamic> json) => RegistrationInfo(
    className: json['className'],
    tableName: json['tableName'],
    libraryUri: json['libraryUri'],
  );
}
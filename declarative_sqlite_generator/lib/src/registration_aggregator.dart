import 'dart:async';

import 'package:build/build.dart';
import 'package:glob/glob.dart';

/// Aggregates metadata from `.dbrecord_meta` files and generates
/// `sqlite_factory_registration.dart`.
class RegistrationAggregator extends Builder {
  @override
  Map<String, List<String>> get buildExtensions => const {
        r'$lib$': ['sqlite_factory_registration.dart']
      };

  @override
  Future<void> build(BuildStep buildStep) async {
    final buffer = StringBuffer();
    buffer.writeln('// Generated by declarative_sqlite_generator. Do not edit.');
    buffer.writeln("import 'package:declarative_sqlite/declarative_sqlite.dart';");

    final metaFiles = buildStep.findAssets(Glob('**/*.dbrecord_meta'));
    final importUris = <String>{};
    final classNames = <String>[];

    await for (final assetId in metaFiles) {
      final content = await buildStep.readAsString(assetId);
      final classes = content.split('\n').where((line) => line.isNotEmpty);
      classNames.addAll(classes);

      // Convert assetId to a package URI for import
      final package = assetId.package;
      final path = assetId.path.replaceFirst('lib/', '').replaceAll('.dbrecord_meta', '.dart');
      importUris.add("import 'package:$package/$path';");
    }

    // Write imports
    importUris.forEach(buffer.writeln);
    buffer.writeln();

    // Write registration function
    buffer.writeln('void registerFactories() {');
    for (final className in classNames) {
      buffer.writeln("  sqliteFactory.register($className.new, (record) => record.clone());");
    }
    buffer.writeln('}');

    final outputId = AssetId(buildStep.inputId.package, 'lib/sqlite_factory_registration.dart');
    await buildStep.writeAsString(outputId, buffer.toString());
  }
}

import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:declarative_sqlite/declarative_sqlite.dart';
import 'table_data_class_generator.dart';
import 'view_data_class_generator.dart';

/// Main code generator that processes SchemaBuilder metadata and generates
/// data classes for all tables and views.
class SchemaCodeGenerator {
  const SchemaCodeGenerator({
    this.tableGenerator = const TableDataClassGenerator(),
    this.viewGenerator = const ViewDataClassGenerator(),
  });

  final TableDataClassGenerator tableGenerator;
  final ViewDataClassGenerator viewGenerator;

  /// Generates Dart code for all tables and views in the schema.
  String generateCode(SchemaBuilder schema, {String? libraryName}) {
    final library = Library((b) => b
      ..name = libraryName
      ..docs.addAll([
        '/// Generated data classes for declarative_sqlite schema.',
        '/// DO NOT EDIT - This file is generated by declarative_sqlite_generator.',
      ])
      ..body.addAll(_generateLibraryBody(schema))
    );

    final emitter = DartEmitter();
    final rawCode = '${library.accept(emitter)}';
    
    try {
      final formatter = DartFormatter();
      return formatter.format(rawCode);
    } catch (e) {
      // If formatting fails, return unformatted code with a warning
      return '// Warning: Could not format generated code: $e\n$rawCode';
    }
  }

  /// Generates the library body with all classes.
  List<Spec> _generateLibraryBody(SchemaBuilder schema) {
    final specs = <Spec>[];

    // Generate data classes for all tables
    for (final table in schema.tables) {
      specs.add(tableGenerator.generateDataClass(table));
    }

    // Generate data classes for all views
    for (final view in schema.views) {
      specs.add(viewGenerator.generateDataClass(view, schema));
    }

    return specs;
  }

  /// Generates code for a specific table only.
  String generateTableCode(TableBuilder table, {String? libraryName}) {
    final library = Library((b) => b
      ..name = libraryName
      ..docs.addAll([
        '/// Generated data class for ${table.name} table.',
        '/// DO NOT EDIT - This file is generated by declarative_sqlite_generator.',
      ])
      ..body.add(tableGenerator.generateDataClass(table))
    );

    final emitter = DartEmitter();
    final rawCode = '${library.accept(emitter)}';
    
    try {
      final formatter = DartFormatter();
      return formatter.format(rawCode);
    } catch (e) {
      return '// Warning: Could not format generated code: $e\n$rawCode';
    }
  }

  /// Generates code for a specific view only.
  String generateViewCode(ViewBuilder view, SchemaBuilder schema, {String? libraryName}) {
    final library = Library((b) => b
      ..name = libraryName
      ..docs.addAll([
        '/// Generated data class for ${view.name} view.',
        '/// DO NOT EDIT - This file is generated by declarative_sqlite_generator.',
      ])
      ..body.add(viewGenerator.generateDataClass(view, schema))
    );

    final emitter = DartEmitter();
    final rawCode = '${library.accept(emitter)}';
    
    try {
      final formatter = DartFormatter();
      return formatter.format(rawCode);
    } catch (e) {
      return '// Warning: Could not format generated code: $e\n$rawCode';
    }
  }

  /// Generates an index file that exports all generated data classes.
  String generateIndexFile(SchemaBuilder schema, {String? libraryName}) {
    final tableExports = schema.tables.map((table) => 
      "export '${_toSnakeCase(table.name)}_data.g.dart';"
    );
    
    final viewExports = schema.views.map((view) => 
      "export '${_toSnakeCase(view.name)}_view_data.g.dart';"
    );

    final library = Library((b) => b
      ..name = libraryName
      ..docs.addAll([
        '/// Generated exports for all declarative_sqlite data classes.',
        '/// DO NOT EDIT - This file is generated by declarative_sqlite_generator.',
      ])
      ..body.addAll([
        ...tableExports.map((export) => refer(export).statement),
        ...viewExports.map((export) => refer(export).statement),
      ])
    );

    final emitter = DartEmitter();
    final rawCode = '${library.accept(emitter)}';
    
    try {
      final formatter = DartFormatter();
      return formatter.format(rawCode);
    } catch (e) {
      return '// Warning: Could not format generated code: $e\n$rawCode';
    }
  }

  /// Converts PascalCase or camelCase to snake_case.
  String _toSnakeCase(String input) {
    return input
        .replaceAllMapped(RegExp(r'([A-Z])'), (match) => '_${match.group(1)!.toLowerCase()}')
        .replaceFirst(RegExp(r'^_'), '');
  }
}
# Copilot Instructions for Declarative SQLite

## Project Overview

This is a Dart package that provides a declarative approach to SQLite schema management and data access. The library implements a fluent builder pattern for defining database schemas and automatically handles migrations and CRUD operations.

## Architecture

### Core Components

1. **SchemaBuilder**: Main entry point for defining database schemas
2. **TableBuilder**: Defines individual table structures with columns and indices
3. **ColumnBuilder**: Specifies column properties, constraints, and data types
4. **IndexBuilder**: Defines table indices (single and composite)
5. **SchemaMigrator**: Handles database migration and validation
6. **DataAccess**: Provides type-safe CRUD operations and bulk data loading

### Design Patterns

- **Immutable Builder Pattern**: All builders are immutable and return new instances
- **Fluent Interface**: Chainable method calls for readable schema definitions
- **Declarative Configuration**: Schema is defined, not executed step-by-step

## Dart Language Guidelines

### Code Style

- Use `@immutable` annotations for all builder classes
- Prefer `const` constructors where possible
- Use named parameters for optional configuration
- Follow Dart naming conventions (camelCase for variables/methods, PascalCase for classes)
- Use trailing commas for better formatting and git diffs

### Error Handling

- Throw `ArgumentError` for invalid configuration (duplicate names, invalid constraints)
- Use descriptive error messages that help developers understand what went wrong
- Validate input at the builder level before SQL generation

### Documentation

- Use triple-slash (`///`) comments for public API documentation
- Include code examples in documentation comments
- Document parameter constraints and return values
- Use `@param` and `@returns` tags where helpful

## Code Patterns

### Builder Pattern Implementation

```dart
@immutable
class ExampleBuilder {
  const ExampleBuilder._({required this.property});
  
  // Public constructor starts with empty/default state
  const ExampleBuilder() : property = defaultValue;
  
  final PropertyType property;
  
  // Builder methods return new instances
  ExampleBuilder withProperty(PropertyType value) {
    return ExampleBuilder._(property: value);
  }
}
```

### Fluent Interface Methods

- Methods should return the builder instance for chaining
- Use descriptive method names that read like natural language
- Group related configuration methods together
- Provide both simple and advanced overloads

### SQL Generation

- Generate standards-compliant SQLite DDL statements
- Handle SQL injection prevention in data access layer
- Use parameterized queries for all data operations
- Validate SQL identifiers (table names, column names)

## Testing Guidelines

### Test Structure

- Use `group()` to organize related tests
- Use descriptive test names that explain the behavior being tested
- Test both positive and negative cases (valid/invalid inputs)
- Include integration tests for complete workflows

### Test Patterns

```dart
group('ComponentName', () {
  test('can perform basic operation', () {
    // Arrange
    final builder = ComponentBuilder();
    
    // Act
    final result = builder.operation();
    
    // Assert
    expect(result.property, equals(expectedValue));
  });
  
  test('throws error for invalid input', () {
    expect(() => ComponentBuilder().invalidOperation(), 
           throwsA(isA<ArgumentError>()));
  });
});
```

### Database Testing

- Use in-memory SQLite databases for tests (`':memory:'`)
- Test schema migration scenarios (empty DB, existing schema)
- Verify generated SQL statements match expectations
- Test data access operations with actual database interactions

## Library-Specific Guidelines

### Schema Definition

- Always validate schema consistency (no duplicate table/column names)
- Support both simple and composite primary keys
- Handle system columns (systemId, systemVersion) automatically
- Provide meaningful validation errors for schema conflicts

### Data Types

- Map Dart types to SQLite affinities correctly:
  - `int` → INTEGER
  - `double` → REAL  
  - `String` → TEXT
  - `Uint8List` → BLOB
- Support nullable and non-nullable columns appropriately
- Handle default values and constraints properly

### Migration Safety

- Only support additive migrations (no destructive changes)
- Validate existing schema before applying changes
- Provide migration preview functionality
- Handle edge cases like existing data conflicts

### Data Access Layer

- Provide type-safe methods that use schema metadata
- Support bulk operations with proper error handling
- Handle missing/extra columns gracefully in bulk loading
- Use transactions for batch operations

## API Design Principles

### Consistency

- Use consistent naming patterns across all builders
- Provide similar method signatures for related operations
- Handle optional parameters uniformly
- Use consistent error types and messages

### Discoverability

- Use method names that clearly indicate their purpose
- Provide multiple ways to achieve common tasks
- Include comprehensive examples in documentation
- Design APIs that guide users toward correct usage

### Performance

- Minimize object allocation in hot paths
- Use efficient SQL generation (avoid string concatenation)
- Batch database operations where possible
- Provide configuration options for performance tuning

## Common Pitfalls to Avoid

1. **Mutating Builder State**: All builders must be immutable
2. **SQL Injection**: Always use parameterized queries for user data
3. **Schema Validation**: Don't skip validation of table/column names and constraints
4. **Transaction Management**: Ensure proper transaction handling in bulk operations
5. **Resource Cleanup**: Close database connections and statements properly

## Development Workflow

### Adding New Features

1. Define the public API first with documentation
2. Implement builder classes with immutable pattern
3. Add SQL generation and validation logic
4. Write comprehensive tests (unit and integration)
5. Update library exports and documentation

### Code Review Checklist

- [ ] All public APIs are documented
- [ ] Builder classes are immutable
- [ ] Error cases are handled with clear messages
- [ ] Tests cover both success and failure scenarios
- [ ] SQL generation is safe and standards-compliant
- [ ] Performance considerations are addressed

## Examples and References

Refer to existing code in `lib/src/` for established patterns and `test/` directory for testing approaches. The library follows standard Dart package conventions and SQLite best practices.